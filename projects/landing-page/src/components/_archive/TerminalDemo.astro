---
---

<div class="terminal-window w-full max-w-3xl mx-auto rounded-xl overflow-hidden shadow-2xl bg-[#1e1e1e] border border-gray-800 font-mono text-sm sm:text-base">
  <!-- Terminal Header -->
  <div class="bg-[#2d2d2d] px-4 py-2 flex items-center justify-between border-b border-gray-700">
    <div class="flex space-x-2">
      <div class="w-3 h-3 rounded-full bg-red-500 hover:bg-red-400 cursor-pointer transition-colors"></div>
      <div class="w-3 h-3 rounded-full bg-yellow-500 hover:bg-yellow-400 cursor-pointer transition-colors"></div>
      <div class="w-3 h-3 rounded-full bg-green-500 hover:bg-green-400 cursor-pointer transition-colors"></div>
    </div>
    <div class="text-gray-400 text-xs font-medium flex items-center gap-1">
      <svg xmlns="http://www.w3.org/2000/svg" class="w-3 h-3" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg>
      agentic-sdlc â€” node
    </div>
    <div class="w-14"></div> <!-- Spacer for center alignment -->
  </div>

  <!-- Terminal Body -->
  <div class="p-6 text-gray-300 min-h-[300px] relative pointer-events-none select-none" id="terminal-body">
    <div id="terminal-content"></div>
    <!-- Cursor will be appended here -->
    <span id="cursor" class="inline-block w-2.5 h-5 bg-gray-400 align-middle ml-1 animate-blink"></span>
  </div>
</div>

<style>
  .animate-blink {
    animation: blink 1s step-end infinite;
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0; }
  }

  /* Syntax highlighting classes */
  :global(.cmd) { color: #9cdcfe; } /* Light Blue */
  :global(.arg) { color: #ce9178; } /* Orange/Brown */
  :global(.flag) { color: #dcdcaa; } /* Yellowish */
  :global(.success) { color: #4ec9b0; font-weight: bold; } /* Teal */
  :global(.info) { color: #569cd6; } /* Blue */
  :global(.comment) { color: #6a9955; font-style: italic; } /* Green */
  :global(.prompt) { color: #c586c0; margin-right: 8px; } /* Purple */
</style>

<script>
  interface CommandStep {
    text: string;
    type: 'command' | 'output';
    delay?: number; // Delay after writing this line
    class?: string;
  }

  const steps: CommandStep[] = [
    { text: "> npm install -g agentic-sdlc", type: 'command', delay: 1500 },
    { text: "+ agentic-sdlc@1.0.0", type: 'output', class: "success", delay: 500 },
    { text: "added 1 package in 0.5s", type: 'output', delay: 800 },
    { text: "", type: 'output', delay: 500 }, // spacer
    
    { text: "> agentic-sdlc create my-super-app", type: 'command', delay: 2000 },
    { text: "âœ” Project initialized successfully", type: 'output', class: "success", delay: 400 },
    { text: "âœ” Git repository initialized", type: 'output', class: "success", delay: 400 },
    { text: "âœ” Dependencies installed", type: 'output', class: "success", delay: 1000 },
    { text: "", type: 'output', delay: 500 },

    { text: "> cd my-super-app", type: 'command', delay: 600 },
    { text: "> /pm Build a viral Todo App with AI", type: 'command', delay: 2500 },
    { text: "ðŸ¤– PM Agent activated...", type: 'output', class: "info", delay: 800 },
    { text: "Analyzing requirements...", type: 'output', delay: 800 },
    { text: "Creating Project Plan v1.0...", type: 'output', delay: 1000 },
    { text: "âœ” Plan Approved. Triggering Design Phase.", type: 'output', class: "success", delay: 2000 },
  ];

  const terminalContent = document.getElementById('terminal-content');
  const cursor = document.getElementById('cursor');

  async function typeWriter(text: string, isCommand: boolean) {
    const line = document.createElement('div');
    if (isCommand) {
        line.innerHTML = `<span class="prompt">$</span>`;
    }
    terminalContent?.appendChild(line);

    // Apply basic syntax highlighting logic roughly
    // For simplicity in this demo, we'll just type char by char and colorize at the end or simple spans
    // A robust highlighter needs parsing, here we fake it for 'command' style
    
    let currentText = "";
    for (let i = 0; i < text.length; i++) {
        currentText += text[i];
        // If it's a command, wrap parts in spans for basic color
        if (isCommand) highlightLine(line, currentText);
        else line.textContent = currentText;
        
        await new Promise(r => setTimeout(r, 40 + Math.random() * 30)); // Random typing speed
    }
    
    // Finalize formatting
    if (isCommand) highlightLine(line, text);
    else {
        // Output formatting
        if (text.includes("âœ”") || text.includes("added")) line.className = "text-[#4ec9b0]";
        else if (text.includes("ðŸ¤–")) line.className = "text-[#569cd6]";
        else line.className = "text-gray-300";
        line.textContent = text; 
    }
  }

  function highlightLine(element: HTMLElement, text: string) {
      // Very basic tokenizer for visual effect
      const parts = text.split(' ');
      let html = `<span class="prompt">$</span>`;
      
      parts.forEach((part, index) => {
          let className = "text-white"; // default
          if (index === 0) className = "cmd"; // command
          else if (part.startsWith('-')) className = "flag";
          else className = "arg";
          
          if (part.startsWith('/')) className = "text-purple-400 font-bold"; // Slash command

          html += `<span class="${className}">${part}</span> `;
      });
      element.innerHTML = html.trim();
  }

  async function runSequence() {
      if (!terminalContent) return;
      terminalContent.innerHTML = ''; // Reset
      
      for (const step of steps) {
          if (step.type === 'command') {
             await typeWriter(step.text.replace('> ', ''), true);
          } else {
             const line = document.createElement('div');
             line.className = step.class || "text-gray-400";
             line.textContent = step.text;
             terminalContent.appendChild(line);
             // Ensure view follows
             terminalContent.scrollTop = terminalContent.scrollHeight;
          }
           await new Promise(r => setTimeout(r, step.delay || 500));
      }
      
      // Loop
      await new Promise(r => setTimeout(r, 3000));
      runSequence();
  }

  // Start when visible
  const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
          if (entry.isIntersecting) {
              runSequence();
              observer.disconnect(); // Run once (then it loops inside)
          }
      });
  });
  
  const terminal = document.querySelector('.terminal-window');
  if (terminal) observer.observe(terminal);

</script>
